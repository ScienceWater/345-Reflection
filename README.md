# Reflection

This reflection is in reference to my time in developing Team 6's semester project, **[BoggleBot](https://github.com/ScienceWater/SSW345)**.

## Design
1. The part of our design process that ultimately proved most useful for later in the project was giving specific consideration to the use cases that the bot needed to cover. Looking through use cases and expected behaviors under every possible unique condition was easily the most comprehensive way to ensure that every feature that needed to be implemented would be.
2. The most difficult part of the design process was designing the architecture. Although we went into this project already having a solid idea of how most of the functions would operate, unfamiliarity with certain APIs that we ended up needing to use resulted in our architecture design not being as thorough and thought out specifically during the design phase.
3. I think that use case analysis was definitely an effective way to go about planning the project. By determining the high-level functions our system would need to accomplish and then working backwards from there, it was the most clear way we could have gone into the implementation phase of the more granular elements while still comprehending what the smaller parts of our system would come together to create.

## Implementation
1. A vast majority of our implementation occurred via group programming sessions in which all three of us would collaboratively work on the same code at the same time. This was very helpful, especially considering we were working with several new APIs with which we all had varying degrees of familiarity. In this way, we could all contribute equivalently even when such an issue would come up, as well as catching errors made by someone else much more quickly as we would be much more likely to notice it as the change was made.
2. The most difficult part of implmementation was probably actually having the bot be continously deployed. There was an overall lack of familiarity with the technologies required for such behavior, and as such there were several instances of testing being impeded by this limitation.
3. After its overall success in this project, I strongly believe that continuing with the practice of pair/group programming would be very helpful for any coding projects I'm involved with in the future. Even if I'm on a project with dozens of simultaneous collaborators, having a partner to bounce ideas off of during the act of coding is still very undeniably helpful.

## Process
1. Having issues open on the GitHub page certainly made it much easier to modularize/delegate our specific goals wherever needed. The Kanban board wasn't very helpful, as we would always just default to looking at the issues page, although I can still see the application in larger projects with more collaborators. Even so, the utility of a to-do list of any capacity cannot be understated.
2. The most difficult part of our design process was reviewing our code changes to ensure there were no uncaught bugs. This was largely due to many of the commits to the GitHub being quite large, thereby making it somewhat difficult to ensure that a new commit could or couldn't be fully approved. For future projects, I would definitely like to make commits on a more frequent basis (for instance, after every one or two new major methods).
3. Both of the things mentioned above, opening issues and smaller commits, are things I would like to take with me moving forward. Additionally, we admittedly did more work directly in the `main` branch than would generally be advisable. It wasn't an issue in this project because of the small scope and the fact that much programming was done in a group, but it is still another note I should keep moving forward.

## Overall
All of the positive development practices I've described above should be used in conjunction with each other in order to make the entire lifecycle of creating a new piece of software as clean and efficient as possible. Pair programming is one of the most helpful techniques I've learned through this project, as it allows multiple programmers with different strengths and weaknesses to support each other where it's needed. However, this is understandably not always possible due to either the size of the project or simply due to both developers having different personal schedules. As such, it's always important to conduct code reviews regularly, but especially so in situations where a developer wrote a section of code on their own. Modularizing the development process as much as possible is another key takeaway, in the form of making/assigning issues, making smaller commits for easier reviews, etc. All in all, these practices compliment each other quite effectively to form a cohesively whole software design process.
